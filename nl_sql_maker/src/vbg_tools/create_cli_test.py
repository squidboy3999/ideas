#!/usr/bin/env python3
# vbg_tools/create_cli_test.py
from __future__ import annotations
import os
import stat
from pathlib import Path
from typing import Any, Dict, List, Optional

import yaml

# Jinja2 is preferred, but we provide a fallback if unavailable.
try:
    from jinja2 import Environment, BaseLoader, StrictUndefined
    _HAS_JINJA = True
except Exception:
    _HAS_JINJA = False


DEFAULT_TEMPLATE = """#!/usr/bin/env bash
# Auto-generated by create_cli_test.py
# Purpose: Simple, human-readable demo — one natural language query per block.
set -euo pipefail

ART_DIR="${ARTIFACTS_DIR:-out}"
DB_PATH="${DB_PATH:-test.db}"
RUNTIME="${RUNTIME:-vbg_runtime}"

echo "Running $(basename "$0") — $(date)"
echo

# --- Featured: LIMIT demonstrations ---
{% for t in featured %}
echo "── {{ "%02d"|format(loop.index) }}. {{ t.label }}"
echo "   NL: {{ t.nl }}"
"$RUNTIME" --sql --db "${DB_PATH}" {{ t.nl_q }}
echo
{% endfor %}

# --- Featured: predicate smoke tests (auto-generated) ---
{% for p in preds %}
echo "── {{ "%02d"|format(loop.index + featured|length) }}. {{ p.label }}"
echo "   NL: {{ p.nl }}"
"$RUNTIME" --sql --db "${DB_PATH}" {{ p.nl_q }}
echo
{% endfor %}

# --- Gold surfaces (each a single NL example) ---
{% for item in gold %}
echo "── {{ "%02d"|format(loop.index + featured|length + preds|length) }}. {{ item.label }}"
echo "   NL: {{ item.nl }}"
# expected: {{ item.sql_comment }}
"$RUNTIME" --sql --db "${DB_PATH}" {{ item.nl_q }}
echo
{% endfor %}

# --- Multipath surfaces (expected: multiple valid SQL paths) ---
{% for m in multi %}
echo "── {{ "%02d"|format(loop.index + featured|length + preds|length + gold|length) }}. {{ m.label }}"
echo "   NL: {{ m.nl }}"
{% for s in m.sqls %}
# expected path {{ loop.index }}: {{ s }}
{% endfor %}
"$RUNTIME" --sql --db "${DB_PATH}" {{ m.nl_q }}
echo
{% endfor %}

# --- Invalid surfaces (should fail to plan/parse) ---
{% for inv in invalid %}
echo "── {{ "%02d"|format(loop.index + featured|length + preds|length + gold|length + multi|length) }}. {{ inv.label }}"
echo "   NL: {{ inv.nl }}"
set +e
"$RUNTIME" --sql --db "${DB_PATH}" {{ inv.nl_q }}
rc=$?
set -e
if [ "$rc" -eq 0 ]; then
  echo "!! WARNING: expected failure, but succeeded"
fi
echo
{% endfor %}

echo "Done."
"""


def _bash_single_quote(s: str) -> str:
    """Return a bash-safe single-quoted string, escaping internal single quotes."""
    if s == "":
        return "''"
    return "'" + s.replace("'", "'\"'\"'") + "'"


def _load_yaml_list_any(path: Path) -> List[Dict[str, Any]]:
    """
    Load a YAML list with flexible shapes:
      - { natural_language, sql_expression }
      - { natural_language, sql_expressions: [...] } / sql_paths: [...]
      - { natural_language } (for invalid)
    Normalizes to: { nl: str, sqls: List[str] }
    """
    if not path.exists():
        return []
    with open(path, "r", encoding="utf-8") as f:
        raw = yaml.safe_load(f) or []
    if not isinstance(raw, list):
        raise ValueError(f"Expected YAML list at {path}, got {type(raw).__name__}")

    out: List[Dict[str, Any]] = []
    for it in raw:
        if not isinstance(it, dict):
            continue
        nl = it.get("natural_language")
        if not isinstance(nl, str) or not nl.strip():
            continue
        sqls: List[str] = []
        if isinstance(it.get("sql_expression"), str):
            sqls = [it["sql_expression"]]
        elif isinstance(it.get("sql_expressions"), list):
            sqls = [s for s in it["sql_expressions"] if isinstance(s, str)]
        elif isinstance(it.get("sql_paths"), list):
            sqls = [s for s in it["sql_paths"] if isinstance(s, str)]
        out.append({"nl": nl, "sqls": sqls})
    return out


def _load_yaml_dict(path: Path) -> Dict[str, Any]:
    if not path.exists():
        return {}
    with open(path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f) or {}


def _discover_featured(vocab: Dict[str, Any], binder: Dict[str, Any]) -> List[Dict[str, str]]:
    """
    Pick a reasonable table + aliases to demonstrate:
      - non-parametric LIMIT 1  (e.g., "show first from users")
      - parametric LIMIT N      (e.g., "show from users limit 5")
    """
    catalogs = (binder.get("catalogs") or {})
    tables = list((catalogs.get("tables") or {}).keys())
    table = "users"
    for t in ("regions", "sales", "users"):
        if t in tables:
            table = t
            break
    if not tables:
        tables = [table]

    conns = (catalogs.get("connectors") or {})
    FROM = conns.get("FROM", "from")

    sel_aliases: List[str] = []
    sv = ((vocab.get("keywords") or {}).get("select_verbs") or {})
    if isinstance(sv, dict):
        for _can, ent in sv.items():
            als = ent.get("aliases")
            if isinstance(als, list):
                sel_aliases.extend([a for a in als if isinstance(a, str)])
    sel_aliases = sorted(set([a for a in sel_aliases if a]))
    sel = sel_aliases[0] if sel_aliases else "show"

    sql_actions = (vocab.get("sql_actions") or {})
    limit_one_aliases = (sql_actions.get("limit_one", {}) or {}).get("aliases", []) or []
    lo = (limit_one_aliases[0] if limit_one_aliases else "first")

    limit_aliases = (sql_actions.get("limit", {}) or {}).get("aliases", []) or []
    lim = (limit_aliases[0] if limit_aliases else "limit")

    return [
        { "label": f"featured: {lo} (LIMIT 1)",
          "nl": f"{sel} {lo} {FROM} {table}",
          "nl_q": _bash_single_quote(f"{sel} {lo} {FROM} {table}") },
        { "label": "featured: limit N",
          "nl": f"{sel} {FROM} {table} {lim} 5",
          "nl_q": _bash_single_quote(f"{sel} {FROM} {table} {lim} 5") },
    ]


def _first_select_alias(vocab: Dict[str, Any]) -> str:
    sel_aliases: List[str] = []
    sv = ((vocab.get("keywords") or {}).get("select_verbs") or {})
    if isinstance(sv, dict):
        for _can, ent in sv.items():
            als = ent.get("aliases")
            if isinstance(als, list):
                sel_aliases.extend([a for a in als if isinstance(a, str)])
    sel_aliases = sorted(set([a for a in sel_aliases if a]))
    return sel_aliases[0] if sel_aliases else "display"


def _discover_predicate_smoke(vocab: Dict[str, Any], binder: Dict[str, Any]) -> List[Dict[str, str]]:
    """
    Generate a few deterministic NL lines that exercise comparison + logical operators:
    - avg of <num-col> from <table> <col> > 10
    - sum of <num-col> from <table> <col> >= 5 and <col> < 100
    - count of <id-col> from users age between 18 and 30
    This requires no 'where' token (grammar attaches constraints directly).
    If we can’t find suitable columns, returns [].
    """
    catalogs = (binder.get("catalogs") or {})
    columns = (catalogs.get("columns") or {})
    conns = (catalogs.get("connectors") or {})
    FROM = conns.get("FROM", "from")
    AND = conns.get("AND", "and")
    OF = conns.get("OF", "of")

    # pick a table and numeric columns
    by_table: Dict[str, List[Dict[str, Any]]] = {}
    for fqn, meta in columns.items():
        tbl = meta.get("table")
        types = set([str(t) for t in (meta.get("slot_types") or [])])
        if not tbl:
            continue
        by_table.setdefault(tbl, []).append({"fqn": fqn, "name": meta.get("name"), "types": types})

    def _num_cols(t: str) -> List[str]:
        cols = by_table.get(t, [])
        out = []
        for c in cols:
            ts = c["types"]
            if {"numeric", "int", "float", "integer", "decimal", "double", "real"} & ts:
                out.append(c["name"])
        return out

    # Prefer sales/users/regions in that order
    table_order = list(by_table.keys())
    for pref in ("sales", "users", "regions"):
        if pref in by_table:
            table_order = [pref] + [t for t in table_order if t != pref]
            break
    if not table_order:
        return []

    # Choose table with ≥1 numeric column
    chosen_table = None
    ncols: List[str] = []
    for t in table_order:
        ncols = _num_cols(t)
        if ncols:
            chosen_table = t
            break
    if not chosen_table:
        return []

    # Build 2-3 examples
    sel = _first_select_alias(vocab)

    preds: List[Dict[str, str]] = []

    # 1) avg on first numeric column with >
    c1 = ncols[0]
    q1 = f"{sel} avg {OF} {c1} {FROM} {chosen_table} {c1} > 10"
    preds.append({
        "label": f"predicate: {c1} > 10",
        "nl": q1,
        "nl_q": _bash_single_quote(q1),
    })

    # 2) sum on same column with >= and < chained by AND
    c2 = ncols[0]
    q2 = f"{sel} sum {OF} {c2} {FROM} {chosen_table} {c2} >= 5 {AND} {c2} < 100"
    preds.append({
        "label": f"predicate: {c2} >= 5 {AND} {c2} < 100",
        "nl": q2,
        "nl_q": _bash_single_quote(q2),
    })

    # 3) If users.age exists, count with between
    has_users_age = any((m.get("table") == "users" and m.get("name") == "age") for m in columns.values())
    if has_users_age:
        q3 = f"{sel} count {OF} age {FROM} users age between 18 and 30"
        preds.append({
            "label": "predicate: age between 18 and 30",
            "nl": q3,
            "nl_q": _bash_single_quote(q3),
        })

    return preds


def _default_env() -> Optional["Environment"]:
    if not _HAS_JINJA:
        return None
    return Environment(
        loader=BaseLoader(),
        autoescape=False,
        trim_blocks=True,
        lstrip_blocks=True,
        undefined=StrictUndefined,
    )


def _render(template: str, context: Dict[str, Any]) -> str:
    """Render with Jinja2 if available; otherwise do a manual fallback."""
    if _HAS_JINJA:
        env = _default_env()
        assert env is not None
        tmpl = env.from_string(template)
        return tmpl.render(**context)

    # ----- Minimal fallback rendering (keeps section structure) -----
    header = """#!/usr/bin/env bash
# Auto-generated by create_cli_test.py (fallback mode)
set -euo pipefail

ART_DIR="${ARTIFACTS_DIR:-out}"
DB_PATH="${DB_PATH:-test.db}"
RUNTIME="${RUNTIME:-vbg_runtime}"

echo "Running $(basename "$0") — $(date)"
echo
"""
    chunks: List[str] = []

    # featured
    for idx, t in enumerate(context.get("featured", []), 1):
        chunks.append(
            "\n".join([
                f'echo "── {idx:02d}. {t["label"]}"',
                f'echo "   NL: {t["nl"]}"',
                f'"$RUNTIME" --sql --db "${{DB_PATH}}" {t["nl_q"]}',
                "echo",
            ])
        )

    # predicate smoke
    offset = len(context.get("featured", []))
    for i, p in enumerate(context.get("preds", []), 1):
        n = offset + i
        chunks.append(
            "\n".join([
                f'echo "── {n:02d}. {p["label"]}"',
                f'echo "   NL: {p["nl"]}"',
                f'"$RUNTIME" --sql --db "${{DB_PATH}}" {p["nl_q"]}',
                "echo",
            ])
        )

    # gold
    base = offset + len(context.get("preds", []))
    for i, it in enumerate(context.get("gold", []), 1):
        n = base + i
        chunks.append(
            "\n".join([
                f'echo "── {n:02d}. {it["label"]}"',
                f'echo "   NL: {it["nl"]}"',
                f'# expected: {it["sql_comment"]}',
                f'"$RUNTIME" --sql --db "${{DB_PATH}}" {it["nl_q"]}',
                "echo",
            ])
        )

    # multipath
    base2 = base + len(context.get("gold", []))
    for i, m in enumerate(context.get("multi", []), 1):
        n = base2 + i
        lines = [
            f'echo "── {n:02d}. {m["label"]}"',
            f'echo "   NL: {m["nl"]}"',
        ]
        for j, s in enumerate(m.get("sqls", []), 1):
            lines.append(f"# expected path {j}: {s}")
        lines += [
            f'"$RUNTIME" --sql --db "${{DB_PATH}}" {m["nl_q"]}',
            "echo",
        ]
        chunks.append("\n".join(lines))

    # invalid
    base3 = base2 + len(context.get("multi", []))
    for i, inv in enumerate(context.get("invalid", []), 1):
        n = base3 + i
        chunks.append(
            "\n".join([
                f'echo "── {n:02d}. {inv["label"]}"',
                f'echo "   NL: {inv["nl"]}"',
                "set +e",
                f'"$RUNTIME" --sql --db "${{DB_PATH}}" {inv["nl_q"]}',
                "rc=$?",
                "set -e",
                'if [ "$rc" -eq 0 ]; then',
                '  echo "!! WARNING: expected failure, but succeeded"',
                "fi",
                "echo",
            ])
        )

    return header + ("\n".join(chunks)) + '\necho "Done."\n'


def generate_cli_test(
    *,
    art_dir: str | Path = "out",
    gold_path: str | Path | None = None,
    multipath_path: str | Path | None = None,
    invalid_path: str | Path | None = None,
    out_path: str | Path | None = None,
    template_path: str | Path | None = None,
    max_items: Optional[int] = None,
) -> Path:
    """
    Build cli_test.sh from:
      - gold_surfaces.yml
      - multipath_surfaces.yml (optional)
      - invalid_surfaces.yml  (optional)
    Includes:
      - Featured LIMIT demos
      - Predicate smoke tests synthesized from artifacts
      - Gold / Multipath / Invalid sections

    Flags:
      - art_dir: where artifacts & YAML live (default 'out')
      - *path: override defaults
      - max_items: optional cap on gold examples (others un-capped)
    """
    art_dir_p = Path(art_dir)
    gold_p = Path(gold_path) if gold_path else (art_dir_p / "gold_surfaces.yml")
    multipath_p = Path(multipath_path) if multipath_path else (art_dir_p / "multipath_surfaces.yml")
    invalid_p = Path(invalid_path) if invalid_path else (art_dir_p / "invalid_surfaces.yml")
    out_p = Path(out_path) if out_path else (art_dir_p / "cli_test.sh")

    # Artifacts to pick aliases/table/connectors
    vocab_p = art_dir_p / "graph_vocabulary.yaml"
    binder_p = art_dir_p / "graph_binder.yaml"

    vocab = _load_yaml_dict(vocab_p)
    binder = _load_yaml_dict(binder_p)

    featured = _discover_featured(vocab, binder)
    preds = _discover_predicate_smoke(vocab, binder)

    # Gold
    gold_items_raw = _load_yaml_list_any(gold_p)
    if max_items is not None:
        gold_items_raw = gold_items_raw[:max_items]
    gold = []
    for rec in gold_items_raw:
        nl = rec["nl"]
        sqls = rec["sqls"]
        sql = sqls[0] if sqls else ""
        gold.append({
            "label": nl,
            "nl": nl,
            "nl_q": _bash_single_quote(nl),
            "sql_comment": (sql.replace("\n", " ") if isinstance(sql, str) else ""),
        })

    # Multipath
    multi_raw = _load_yaml_list_any(multipath_p)
    multi = []
    for rec in multi_raw:
        nl = rec["nl"]
        sqls = [s.replace("\n", " ") for s in rec.get("sqls", [])]
        multi.append({
            "label": f"multipath: {nl}",
            "nl": nl,
            "nl_q": _bash_single_quote(nl),
            "sqls": sqls,
        })

    # Invalid
    invalid_raw = _load_yaml_list_any(invalid_p)
    invalid = []
    for rec in invalid_raw:
        nl = rec["nl"]
        invalid.append({
            "label": f"invalid: {nl}",
            "nl": nl,
            "nl_q": _bash_single_quote(nl),
        })

    # Load template
    tpl_text = Path(template_path).read_text(encoding="utf-8") if template_path else DEFAULT_TEMPLATE
    rendered = _render(tpl_text, {
        "featured": featured,
        "preds": preds,
        "gold": gold,
        "multi": multi,
        "invalid": invalid,
    })

    # Ensure out dir
    out_p.parent.mkdir(parents=True, exist_ok=True)
    out_p.write_text(rendered, encoding="utf-8")

    # chmod +x
    mode = out_p.stat().st_mode
    out_p.chmod(mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

    return out_p


def main(argv: Optional[List[str]] = None) -> int:
    """
    CLI:
      python -m vbg_tools.create_cli_test
      python -m vbg_tools.create_cli_test --max 50
      python -m vbg_tools.create_cli_test --gold other.yml --multi other_multi.yml --invalid other_invalid.yml --out out/cli_test.sh --tpl my.tpl
    """
    import argparse
    p = argparse.ArgumentParser(description="Generate a clean cli_test.sh from surface YAMLs and artifacts")
    p.add_argument("--art-dir", default=os.environ.get("ARTIFACTS_DIR", "out"))
    p.add_argument("--gold", dest="gold_path")
    p.add_argument("--multi", dest="multipath_path")
    p.add_argument("--invalid", dest="invalid_path")
    p.add_argument("--out", dest="out_path")
    p.add_argument("--tpl", dest="template_path")
    p.add_argument("--max", dest="max_items", type=int)
    args = p.parse_args(argv)

    out_file = generate_cli_test(
        art_dir=args.art_dir,
        gold_path=args.gold_path,
        multipath_path=args.multipath_path,
        invalid_path=args.invalid_path,
        out_path=args.out_path,
        template_path=args.template_path,
        max_items=args.max_items,
    )
    print(f"Wrote: {out_file}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
